"""
Vulnerability Chain Analyzer
Analyzes relationships between vulnerabilities to identify complex attack chains
"""
import json
import logging
from typing import Dict, List, Any, Tuple, Optional
from dataclasses import dataclass, field
from datetime import datetime
import networkx as nx
from collections import defaultdict
import hashlib

logger = logging.getLogger(__name__)


@dataclass
class VulnerabilityNode:
    """Represents a vulnerability in the chain"""
    vuln_id: str
    vuln_type: str
    severity: str
    confidence: float
    file_path: str
    description: str
    exploitability: float
    impact: float
    
    def __hash__(self):
        return hash(self.vuln_id)


@dataclass
class AttackChain:
    """Represents a potential attack chain"""
    chain_id: str
    vulnerabilities: List[VulnerabilityNode]
    chain_type: str  # lateral_movement, privilege_escalation, data_exfiltration
    total_risk_score: float
    exploitability_score: float
    impact_score: float
    description: str
    mitre_tactics: List[str] = field(default_factory=list)
    kill_chain_stages: List[str] = field(default_factory=list)


class VulnerabilityChainAnalyzer:
    """
    Analyzes vulnerabilities to identify complex attack chains and relationships
    """
    
    def __init__(self):
        # Define vulnerability relationships
        self.vulnerability_relationships = {
            'sql_injection': {
                'can_lead_to': ['data_breach', 'privilege_escalation', 'remote_code_execution'],
                'requires': [],
                'mitre_tactic': 'TA0001'  # Initial Access
            },
            'authentication_bypass': {
                'can_lead_to': ['privilege_escalation', 'unauthorized_access', 'data_breach'],
                'requires': [],
                'mitre_tactic': 'TA0001'
            },
            'privilege_escalation': {
                'can_lead_to': ['data_breach', 'system_compromise', 'lateral_movement'],
                'requires': ['authentication_bypass', 'initial_access'],
                'mitre_tactic': 'TA0004'
            },
            'remote_code_execution': {
                'can_lead_to': ['system_compromise', 'data_breach', 'lateral_movement'],
                'requires': [],
                'mitre_tactic': 'TA0002'  # Execution
            },
            'insecure_deserialization': {
                'can_lead_to': ['remote_code_execution', 'denial_of_service'],
                'requires': [],
                'mitre_tactic': 'TA0002'
            },
            'path_traversal': {
                'can_lead_to': ['information_disclosure', 'file_access'],
                'requires': [],
                'mitre_tactic': 'TA0009'  # Collection
            },
            'ssrf': {
                'can_lead_to': ['internal_network_access', 'data_breach'],
                'requires': [],
                'mitre_tactic': 'TA0007'  # Discovery
            },
            'xxe': {
                'can_lead_to': ['information_disclosure', 'ssrf', 'denial_of_service'],
                'requires': [],
                'mitre_tactic': 'TA0009'
            },
            'csrf': {
                'can_lead_to': ['unauthorized_actions', 'privilege_escalation'],
                'requires': ['authenticated_session'],
                'mitre_tactic': 'TA0005'  # Defense Evasion
            },
            'weak_cryptography': {
                'can_lead_to': ['data_breach', 'authentication_bypass'],
                'requires': [],
                'mitre_tactic': 'TA0005'
            }
        }
        
        # Kill chain stages
        self.kill_chain_stages = [
            'reconnaissance',
            'weaponization',
            'delivery',
            'exploitation',
            'installation',
            'command_and_control',
            'actions_on_objectives'
        ]
    
    def analyze_chains(self, vulnerabilities: List[Dict[str, Any]]) -> List[AttackChain]:
        """
        Analyze vulnerabilities to identify potential attack chains
        
        Args:
            vulnerabilities: List of vulnerability findings
            
        Returns:
            List of identified attack chains
        """
        if not vulnerabilities:
            return []
        
        # Convert to vulnerability nodes
        vuln_nodes = self._create_vulnerability_nodes(vulnerabilities)
        
        # Build vulnerability graph
        vuln_graph = self._build_vulnerability_graph(vuln_nodes)
        
        # Identify attack chains
        attack_chains = []
        
        # Find privilege escalation chains
        priv_esc_chains = self._find_privilege_escalation_chains(vuln_graph, vuln_nodes)
        attack_chains.extend(priv_esc_chains)
        
        # Find data exfiltration chains
        data_exfil_chains = self._find_data_exfiltration_chains(vuln_graph, vuln_nodes)
        attack_chains.extend(data_exfil_chains)
        
        # Find lateral movement chains
        lateral_chains = self._find_lateral_movement_chains(vuln_graph, vuln_nodes)
        attack_chains.extend(lateral_chains)
        
        # Find RCE chains
        rce_chains = self._find_rce_chains(vuln_graph, vuln_nodes)
        attack_chains.extend(rce_chains)
        
        # Rank chains by risk
        attack_chains.sort(key=lambda x: x.total_risk_score, reverse=True)
        
        return attack_chains
    
    def _create_vulnerability_nodes(self, vulnerabilities: List[Dict[str, Any]]) -> List[VulnerabilityNode]:
        """Convert vulnerability findings to nodes"""
        nodes = []
        
        for vuln in vulnerabilities:
            # Determine exploitability
            exploitability = self._calculate_exploitability(vuln)
            
            # Determine impact
            impact = self._calculate_impact(vuln)
            
            node = VulnerabilityNode(
                vuln_id=vuln.get('finding_id', hashlib.sha256(str(vuln).encode()).hexdigest()[:8]),
                vuln_type=vuln.get('finding_type', 'unknown'),
                severity=vuln.get('severity', 'MEDIUM'),
                confidence=vuln.get('confidence', 0.5),
                file_path=vuln.get('file_path', ''),
                description=vuln.get('description', ''),
                exploitability=exploitability,
                impact=impact
            )
            nodes.append(node)
        
        return nodes
    
    def _build_vulnerability_graph(self, vuln_nodes: List[VulnerabilityNode]) -> nx.DiGraph:
        """Build a directed graph of vulnerability relationships"""
        graph = nx.DiGraph()
        
        # Add nodes
        for node in vuln_nodes:
            graph.add_node(node.vuln_id, data=node)
        
        # Add edges based on relationships
        for node in vuln_nodes:
            vuln_type = self._normalize_vuln_type(node.vuln_type)
            
            if vuln_type in self.vulnerability_relationships:
                relationships = self.vulnerability_relationships[vuln_type]
                
                # Find nodes that this vulnerability can lead to
                for target_type in relationships.get('can_lead_to', []):
                    for target_node in vuln_nodes:
                        if self._normalize_vuln_type(target_node.vuln_type) == target_type:
                            # Add edge with weight based on likelihood
                            weight = self._calculate_edge_weight(node, target_node)
                            graph.add_edge(node.vuln_id, target_node.vuln_id, weight=weight)
        
        return graph
    
    def _find_privilege_escalation_chains(self, graph: nx.DiGraph, 
                                         vuln_nodes: List[VulnerabilityNode]) -> List[AttackChain]:
        """Find chains that lead to privilege escalation"""
        chains = []
        
        # Find starting points (entry vulnerabilities)
        entry_vulns = [n for n in vuln_nodes if self._is_entry_vulnerability(n)]
        
        # Find privilege escalation endpoints
        priv_esc_vulns = [n for n in vuln_nodes if 'privilege' in n.vuln_type.lower()]
        
        for start in entry_vulns:
            for end in priv_esc_vulns:
                if start.vuln_id != end.vuln_id:
                    try:
                        # Find all paths
                        paths = list(nx.all_simple_paths(graph, start.vuln_id, end.vuln_id, cutoff=5))
                        
                        for path in paths:
                            chain = self._create_attack_chain(path, graph, 'privilege_escalation')
                            if chain:
                                chains.append(chain)
                    except nx.NetworkXNoPath:
                        continue
        
        return chains
    
    def _find_data_exfiltration_chains(self, graph: nx.DiGraph,
                                      vuln_nodes: List[VulnerabilityNode]) -> List[AttackChain]:
        """Find chains that could lead to data exfiltration"""
        chains = []
        
        # Data access vulnerabilities
        data_vulns = [n for n in vuln_nodes if any(term in n.vuln_type.lower() 
                     for term in ['sql', 'xxe', 'path_traversal', 'information_disclosure'])]
        
        # Network egress vulnerabilities
        egress_vulns = [n for n in vuln_nodes if any(term in n.vuln_type.lower()
                       for term in ['ssrf', 'rce', 'command_injection'])]
        
        for data_vuln in data_vulns:
            for egress_vuln in egress_vulns:
                if data_vuln.vuln_id != egress_vuln.vuln_id:
                    # Create direct chain even if no path exists
                    chain_vulns = [data_vuln, egress_vuln]
                    chain = self._create_attack_chain_from_nodes(chain_vulns, 'data_exfiltration')
                    if chain:
                        chains.append(chain)
        
        return chains
    
    def _find_lateral_movement_chains(self, graph: nx.DiGraph,
                                     vuln_nodes: List[VulnerabilityNode]) -> List[AttackChain]:
        """Find chains that enable lateral movement"""
        chains = []
        
        # Initial compromise vulnerabilities
        initial_vulns = [n for n in vuln_nodes if self._is_entry_vulnerability(n)]
        
        # Lateral movement enablers
        lateral_vulns = [n for n in vuln_nodes if any(term in n.vuln_type.lower()
                        for term in ['ssrf', 'rce', 'authentication', 'session'])]
        
        for start in initial_vulns:
            for lateral in lateral_vulns:
                if start.vuln_id != lateral.vuln_id:
                    chain_vulns = [start, lateral]
                    chain = self._create_attack_chain_from_nodes(chain_vulns, 'lateral_movement')
                    if chain:
                        chains.append(chain)
        
        return chains
    
    def _find_rce_chains(self, graph: nx.DiGraph,
                        vuln_nodes: List[VulnerabilityNode]) -> List[AttackChain]:
        """Find chains leading to remote code execution"""
        chains = []
        
        # RCE vulnerabilities
        rce_vulns = [n for n in vuln_nodes if any(term in n.vuln_type.lower()
                    for term in ['rce', 'code_execution', 'command_injection', 'deserialization'])]
        
        # Entry points that could lead to RCE
        entry_vulns = [n for n in vuln_nodes if self._is_entry_vulnerability(n)]
        
        for entry in entry_vulns:
            for rce in rce_vulns:
                if entry.vuln_id != rce.vuln_id:
                    chain_vulns = [entry, rce]
                    chain = self._create_attack_chain_from_nodes(chain_vulns, 'remote_code_execution')
                    if chain:
                        chains.append(chain)
        
        return chains
    
    def _create_attack_chain(self, path: List[str], graph: nx.DiGraph, chain_type: str) -> Optional[AttackChain]:
        """Create an attack chain from a path in the graph"""
        if len(path) < 2:
            return None
        
        # Get vulnerability nodes
        vulns = []
        for vuln_id in path:
            node_data = graph.nodes[vuln_id].get('data')
            if node_data:
                vulns.append(node_data)
        
        return self._create_attack_chain_from_nodes(vulns, chain_type)
    
    def _create_attack_chain_from_nodes(self, vulns: List[VulnerabilityNode], chain_type: str) -> Optional[AttackChain]:
        """Create an attack chain from vulnerability nodes"""
        if not vulns:
            return None
        
        # Calculate chain scores
        total_risk = self._calculate_chain_risk(vulns)
        exploitability = self._calculate_chain_exploitability(vulns)
        impact = self._calculate_chain_impact(vulns)
        
        # Generate chain ID
        chain_id = hashlib.sha256(
            f"{chain_type}:{':'.join([v.vuln_id for v in vulns])}".encode()
        ).hexdigest()[:12]
        
        # Generate description
        description = self._generate_chain_description(vulns, chain_type)
        
        # Map to MITRE tactics
        mitre_tactics = self._map_to_mitre_tactics(vulns)
        
        # Map to kill chain stages
        kill_chain_stages = self._map_to_kill_chain(vulns, chain_type)
        
        return AttackChain(
            chain_id=chain_id,
            vulnerabilities=vulns,
            chain_type=chain_type,
            total_risk_score=total_risk,
            exploitability_score=exploitability,
            impact_score=impact,
            description=description,
            mitre_tactics=mitre_tactics,
            kill_chain_stages=kill_chain_stages
        )
    
    def _calculate_exploitability(self, vuln: Dict[str, Any]) -> float:
        """Calculate exploitability score for a vulnerability"""
        base_score = 0.5
        
        # Adjust based on confidence
        confidence = vuln.get('confidence', 0.5)
        base_score *= confidence
        
        # Adjust based on vulnerability type
        vuln_type = vuln.get('finding_type', '').lower()
        if any(term in vuln_type for term in ['sql', 'rce', 'command']):
            base_score += 0.3
        elif any(term in vuln_type for term in ['auth', 'csrf']):
            base_score += 0.2
        
        # Adjust based on severity
        severity = vuln.get('severity', 'MEDIUM')
        severity_multipliers = {'CRITICAL': 1.5, 'HIGH': 1.2, 'MEDIUM': 1.0, 'LOW': 0.8}
        base_score *= severity_multipliers.get(severity, 1.0)
        
        return min(1.0, base_score)
    
    def _calculate_impact(self, vuln: Dict[str, Any]) -> float:
        """Calculate impact score for a vulnerability"""
        base_score = 0.5
        
        # Adjust based on business context
        business_risk = vuln.get('business_risk_score', 0.5)
        base_score = (base_score + business_risk) / 2
        
        # Adjust based on vulnerability type
        vuln_type = vuln.get('finding_type', '').lower()
        if any(term in vuln_type for term in ['data', 'breach', 'disclosure']):
            base_score += 0.3
        elif any(term in vuln_type for term in ['dos', 'denial']):
            base_score += 0.1
        
        return min(1.0, base_score)
    
    def _calculate_edge_weight(self, source: VulnerabilityNode, target: VulnerabilityNode) -> float:
        """Calculate the weight of an edge between two vulnerabilities"""
        # Base weight on exploitability and proximity
        weight = (source.exploitability + target.exploitability) / 2
        
        # Adjust based on file proximity
        if source.file_path == target.file_path:
            weight *= 1.5
        
        return min(1.0, weight)
    
    def _normalize_vuln_type(self, vuln_type: str) -> str:
        """Normalize vulnerability type for matching"""
        vuln_type_lower = vuln_type.lower()
        
        # Map to known types
        if 'sql' in vuln_type_lower:
            return 'sql_injection'
        elif 'auth' in vuln_type_lower and 'bypass' in vuln_type_lower:
            return 'authentication_bypass'
        elif 'privilege' in vuln_type_lower:
            return 'privilege_escalation'
        elif 'rce' in vuln_type_lower or 'remote_code' in vuln_type_lower:
            return 'remote_code_execution'
        elif 'deserializ' in vuln_type_lower:
            return 'insecure_deserialization'
        elif 'path' in vuln_type_lower and 'traversal' in vuln_type_lower:
            return 'path_traversal'
        elif 'ssrf' in vuln_type_lower:
            return 'ssrf'
        elif 'xxe' in vuln_type_lower:
            return 'xxe'
        elif 'csrf' in vuln_type_lower:
            return 'csrf'
        elif 'crypto' in vuln_type_lower:
            return 'weak_cryptography'
        
        return vuln_type_lower
    
    def _is_entry_vulnerability(self, vuln: VulnerabilityNode) -> bool:
        """Check if vulnerability can be an entry point"""
        entry_types = ['injection', 'auth', 'upload', 'input', 'validation', 'csrf']
        return any(term in vuln.vuln_type.lower() for term in entry_types)
    
    def _calculate_chain_risk(self, vulns: List[VulnerabilityNode]) -> float:
        """Calculate total risk score for a chain"""
        if not vulns:
            return 0.0
        
        # Compound risk calculation
        risk = 1.0
        for vuln in vulns:
            vuln_risk = (vuln.exploitability * 0.6 + vuln.impact * 0.4)
            risk *= (1 - vuln_risk)
        
        return 1 - risk
    
    def _calculate_chain_exploitability(self, vulns: List[VulnerabilityNode]) -> float:
        """Calculate chain exploitability"""
        if not vulns:
            return 0.0
        
        # Chain is as hard to exploit as its hardest link
        return min(vuln.exploitability for vuln in vulns)
    
    def _calculate_chain_impact(self, vulns: List[VulnerabilityNode]) -> float:
        """Calculate chain impact"""
        if not vulns:
            return 0.0
        
        # Impact is the maximum of all vulnerabilities
        return max(vuln.impact for vuln in vulns)
    
    def _generate_chain_description(self, vulns: List[VulnerabilityNode], chain_type: str) -> str:
        """Generate human-readable description of attack chain"""
        if not vulns:
            return "Empty attack chain"
        
        descriptions = {
            'privilege_escalation': f"Attack chain allowing privilege escalation through {len(vulns)} steps: " +
                                   " → ".join([v.vuln_type for v in vulns]),
            'data_exfiltration': f"Data exfiltration chain exploiting {vulns[0].vuln_type} for data access " +
                                f"and {vulns[-1].vuln_type} for data extraction",
            'lateral_movement': f"Lateral movement chain from {vulns[0].vuln_type} " +
                               f"enabling network traversal via {vulns[-1].vuln_type}",
            'remote_code_execution': f"RCE chain starting with {vulns[0].vuln_type} " +
                                    f"leading to code execution through {vulns[-1].vuln_type}"
        }
        
        return descriptions.get(chain_type, f"Attack chain with {len(vulns)} vulnerabilities")
    
    def _map_to_mitre_tactics(self, vulns: List[VulnerabilityNode]) -> List[str]:
        """Map vulnerabilities to MITRE ATT&CK tactics"""
        tactics = set()
        
        for vuln in vulns:
            vuln_type = self._normalize_vuln_type(vuln.vuln_type)
            if vuln_type in self.vulnerability_relationships:
                tactic = self.vulnerability_relationships[vuln_type].get('mitre_tactic')
                if tactic:
                    tactics.add(tactic)
        
        return sorted(list(tactics))
    
    def _map_to_kill_chain(self, vulns: List[VulnerabilityNode], chain_type: str) -> List[str]:
        """Map attack chain to kill chain stages"""
        stages = []
        
        # Map based on chain type
        if chain_type == 'privilege_escalation':
            stages = ['exploitation', 'installation', 'command_and_control']
        elif chain_type == 'data_exfiltration':
            stages = ['exploitation', 'actions_on_objectives']
        elif chain_type == 'lateral_movement':
            stages = ['exploitation', 'installation', 'command_and_control']
        elif chain_type == 'remote_code_execution':
            stages = ['delivery', 'exploitation', 'installation']
        
        return stages